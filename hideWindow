#!/home/tobecci/.nvm/versions/node/v18.16.1/bin/node
let { execFileSync, execFile } = /** @ts-ignore */ require('child_process');
const { ensureCorrectDesktopPanelColor } = require('./workers/ensurePanelAppearance')
let { readFileSync, writeFileSync } = require('fs')
let { isMainThread, Worker, workerData } = require('worker_threads')

let configFile = '/home/tobecci/Documents/dev/scripts/xfceWindowHide/hideWindowConfig.json';

let errorFile = '/home/tobecci/Documents/dev/scripts/xfceWindowHide/hideWindowErrors.json';

let persistentWindowNamesFile = '/home/tobecci/Documents/dev/scripts/xfceWindowHide/cache/persistentWindowNames.json'

//desktop names
let defaultDesktop = '0'
let workDesktop = '1'
let hiddenDesktop = '2'

let commandFullPaths = {
	wmctrl: '/usr/bin/wmctrl',
	xdotool: '/usr/bin/xdotool',
	paplay: '/usr/bin/paplay',
	notifySend: '/usr/bin/notify-send'
}

let functionMapping = {
	"switch_desktop": switchDesktop,
	"hide_active": hideActiveWindow,
	"unhide_all": unhideAllWindows,
	"change_window_desktop": changeActiveWindowDesktop,
	"show_hidden_count": listNumberOfHiddenWindows,
	"switch_to_hidden_workspace": toggleHiddenWindowsWorkspace,
	"hide_all_windows_on_current_desktop": hideAllWindowsOnCurrentDesktop,
	"maximize_all_windows": maximizeAllWindows,
	'launch_app': launchApp,
	'ensure_desktop_panel_color': ensureCorrectDesktopPanelColor,
	"start_operational_loop": startOperationalLoop,
	"rename_active_window": renameActiveWindow,
	"map": showMap
}

/**********************************************************************
 * UTILITY FUNCTIONS
 **********************************************************************/

function getConfigData() {
	let fileData = readFileSync(configFile, { encoding: 'utf8' })
	return JSON.parse(fileData);
}

function updateConfigData(data) {
	writeFileSync(configFile, JSON.stringify(data, null, 2))
}

function createLockFile() {

}

function removeLockFile() {

}

let utils = {
	data: {
		timeInMilliSeconds: 400
	},
	functions: {

	}
}

async function sendNotification(message, timeInMilliSeconds = false) {
	if (timeInMilliSeconds) {
		utils.functions.runCommand(`${commandFullPaths.notifySend} '${message}' -t ${timeInMilliSeconds}`, true)
	} else {
		utils.functions.runCommand(`${commandFullPaths.notifySend} '${message}' -t ${utils.data.timeInMilliSeconds}`, true)
		return;
	}
}
/**
 * @typedef { Object } soundType
 * @property success
 * @property error
 * @property alert
 */

async function playNotificationSound({ numberOfTimes = 1, /** @type { soundType } ***/ soundType = 'alert' }) {
	const soundMap = {
		'success': `${commandFullPaths.paplay}  /usr/share/sounds/freedesktop/stereo/complete.oga`,
		'error': `${commandFullPaths.paplay}  /usr/share/sounds/freedesktop/stereo/audio-test-signal.oga`,
		'alert': `${commandFullPaths.paplay} /usr/share/sounds/freedesktop/stereo/message.oga`
	}



	let command = "/usr/bin/pactl set-sink-mute @DEFAULT_SINK@ 0; /usr/bin/pactl set-sink-volume @DEFAULT_SINK@ 100%;";
	for (let i = 0; i < numberOfTimes; i++) {
		command = `${command} ${soundMap[soundType]};`
	}
	utils.functions.runCommand(command, true)
}


function decideIndex(obj) {
	let isNotEmpty = JSON.stringify(obj) !== '{}'
	if (Boolean(obj) && isNotEmpty) {
		let lastIndex = Object.keys(obj)[Object.keys(obj).length - 1]
		let nextIndex = parseInt(lastIndex) + 1
		return nextIndex.toString()
	} else {
		return '0';
	}
}

function getLayout(collapsed = false) {
	const windowsToIgnore = ['xfce4-panel', 'Desktop', 'xfce4-notifyd']
	const desktopTable = { [defaultDesktop]: {}, [workDesktop]: {}, [hiddenDesktop]: {}, }
	const desktopTableArray = []

	let data = utils.functions.runCommand(`${commandFullPaths.wmctrl} -l -G | sort -n -k4`)
	let lines = data.split("\n")

	if (lines[lines.length - 1] === '') lines.pop();

	for (let key in lines) {
		const currentLine = lines[key]
		const hostname = utils.functions.runCommand('/usr/bin/hostname');
		const regex = RegExp(`(?<=${hostname}\\s+).*`)
		const windowNameSearchResult = currentLine.match(regex);
		let windowName = false;
		let windowClass = false;

		let windowInfoArray = currentLine.split(' ');

		windowName = windowNameSearchResult ? windowNameSearchResult[0] : false;

		if (windowsToIgnore.includes(windowName) || !Boolean(windowName)) {
			continue
		}

		let windowId = windowInfoArray[0]
		let desktopNumber = windowInfoArray[2]

		const windowClassCommandOutput = utils.functions.runCommand(`/usr/bin/xprop -id ${windowId} WM_CLASS`)
		const windowClassSearchResult = windowClassCommandOutput.match(/(?<=WM_CLASS\(STRING\)\s+=\s+).*/i)
		windowClass = windowClassSearchResult ? windowClassSearchResult[0] : false;

		const windowData = { "windowId": windowId, "windowName": windowName, "windowClass": windowClass };

		if (!collapsed) {
			let index = decideIndex(desktopTable[desktopNumber])
			desktopTable[desktopNumber][index] = windowData
		} else {
			desktopTableArray.push(windowData);
		}
	}
	if (!collapsed) {
		return desktopTable;
	} else {
		return desktopTableArray;
	}
}

function updateConfigField(fieldName, data) {
	let config = getConfigData()
	config[fieldName] = data
	updateConfigData(config)
}

function printMapping() {
	console.log('available keys', functionMapping)
}


/**********************************************************************
 * ACTION(need to think of a better name) FUNCTIONS
 **********************************************************************/



function getActiveWindowId() {
	try {
		let command = "/usr/bin/xdotool getwindowfocus"
		let result = utils.functions.runCommand(command)
		let windowId = parseInt(result)
		windowId = `0x0${windowId.toString(16)}`
		return windowId
	} catch (error) {
		sendNotification('error getting active windowId')
	}
}

function listAllDesktops() {
	let command = `${commandFullPaths.wmctrl} -d`
	let result = utils.functions.runCommand(command)
	let lines = result.split('\n')
	lines.pop();
	let desktops = lines.map((line) => {
		return line.slice(0, 1)
	})
	return desktops
}

function getActiveDesktop() {
	let command = `${commandFullPaths.wmctrl} -d | grep '*'`
	let result = utils.functions.runCommand(command)
	result = result.slice(0, 1)
	return result;
}

/**
 * this would typically happen before a switch
 * @param desktopNumber
 */
function updateCurrentAsLastDesktop(activeDesktop) {
	let config = getConfigData()
	config['lastDesktop'] = activeDesktop
	updateConfigData(config)
}


function hideActiveWindow(options = []) {
	// if on hidden desktop, unhide instead
	if (getActiveDesktop() === hiddenDesktop) {
		const config = getConfigData();

		utils.functions.runCommand(`${commandFullPaths.wmctrl} -i -r '${getActiveWindowId()}' -t '${config['lastDesktop']}'`, true);
		// playNotificationSound({ numberOfTimes: 1, soundType: 'success' });
	} else {
		//else, hide
		// playNotificationSound({ numberOfTimes: 1, soundType: 'error' });
		utils.functions.runCommand(`${commandFullPaths.wmctrl} -i -r '${getActiveWindowId()}' -t '${hiddenDesktop}'`, true);
	}
}

function unhideWindowById(windowId, desktopToRestoreTo) {
	command = `${commandFullPaths.wmctrl} -i -r '${windowId}' -t ${desktopToRestoreTo}`
	utils.functions.runCommand(command, true);
}


function unhideAllWindows(options = []) {
	let layout = getLayout();
	let hiddenWindowArray = layout['2']
	const config = getConfigData();
	const desktopToRestoreTo = config['lastDesktop']

	for (let key in hiddenWindowArray) {
		unhideWindowById(hiddenWindowArray[key].windowId, desktopToRestoreTo)
	}
	// playNotificationSound({ numberOfTimes: 1, soundType: 'success' });
}

function hideWindowById(windowId) {
	command = `${commandFullPaths.wmctrl} -i -r '${windowId}' -t ${hiddenDesktop}`
	utils.functions.runCommand(command, true);
}

function hideAllWindowsOnCurrentDesktop(options = []) {
	let activeDesktop = getActiveDesktop()

	if (activeDesktop === hiddenDesktop) {
		//do nothing
		// playNotificationSound({ numberOfTimes: 1, soundType: 'error' });
		return;
	} else {
		let desktopLayout = getLayout();
		let windowList = desktopLayout[activeDesktop]
		for (let key in windowList) {
			let id = windowList[key].windowId
			hideWindowById(id)
		}
		// playNotificationSound({ numberOfTimes: 1, soundType: 'success' });
	}

}

function maximizeSingleWindowById(id) {
	// const commandToFocusWindow = `${commandFullPaths.wmctrl} -i -a ${id}`
	// utils.functions.runCommand(commandToFocusWindow, true)
	const commandToUnMaximize = `${commandFullPaths.wmctrl} -i -r ${id} -b remove,maximized_vert,maximized_horz`
	// utils.functions.runCommand(commandToUnMaximize)
	const commandToMaximize = `${commandFullPaths.wmctrl} -i -r ${id} -b add,maximized_vert,maximized_horz`
	// utils.functions.runCommand(commandToMaximize)

	utils.functions.runCommand(`${commandToUnMaximize} && ${commandToMaximize}`, true)
}

function maximizeAllWindows(options = []) {
	let activeWindowId = getActiveWindowId();
	let windowList = getLayout(true);
	let count = 0;

	function maximizeAllInList() {
		for (let key in windowList) {
			let id = windowList[key].windowId;
			maximizeSingleWindowById(id);
		}
	}

	// while (count < 2) { maximizeAllInList(); count++ }
	maximizeAllInList();

	//give focus to initially active window
	utils.functions.runCommand(`${commandFullPaths.wmctrl} -i -a ${activeWindowId}`, true)
	// playNotificationSound({ numberOfTimes: 1, soundType: 'success' });
}

function switchDesktop(options = []) {
	try {
		let activeDesktop = getActiveDesktop();
		if (activeDesktop === hiddenDesktop) {
			//do nothing
			// playNotificationSound({ numberOfTimes: 1, soundType: 'error' });
			return
		} else {
			// switch the desktop
			let desktopToMoveTo = {
				[defaultDesktop]: [workDesktop],
				[workDesktop]: [defaultDesktop]
			}

			// playNotificationSound({ numberOfTimes: 1, soundType: 'alert' })
			utils.functions.runCommand(`${commandFullPaths.wmctrl} -s ${desktopToMoveTo[activeDesktop]}`, true)
			return
		}
	} catch (error) {
		logError(error)
	}
}

function toggleHiddenWindowsWorkspace(options = []) {
	//if on the hidden desktop, go to the last workspace
	const currentDesktop = getActiveDesktop();

	if (currentDesktop === hiddenDesktop) {
		const config = getConfigData()
		//swtich to last desktop
		utils.functions.runCommand(`${commandFullPaths.wmctrl} -s ${config['lastDesktop']}`, true)
		return
	} else {
		//go to hidden desktop
		updateCurrentAsLastDesktop(currentDesktop)
		// playNotificationSound({ numberOfTimes: 1, soundType: 'error' })
		utils.functions.runCommand(`${commandFullPaths.wmctrl} -s ${hiddenDesktop}`, true)
		return
	}

}

function resolveWindowPosition(windowId, desktopId) {
	let destinationDesktopLayout = getLayout()[desktopId]
	let index = Object.keys(destinationDesktopLayout)[Object.keys(destinationDesktopLayout).length - 1]
	let idOflastWindowInDestination = destinationDesktopLayout[index].windowId

	let commandToResolveWindowPosition = `${commandFullPaths.wmctrl} -i -r ${windowId} -b remove,above && ${commandFullPaths.wmctrl} -i -r ${idOflastWindowInDestination} -b add,above`
	utils.functions.runCommand(commandToResolveWindowPosition)
}

function changeActiveWindowDesktop(options = []) {
	let activeWindowId = getActiveWindowId();
	let activeDesktop = getActiveDesktop()
	if (activeDesktop === hiddenDesktop) {
		//do nothing
		sendNotification('that action is prohibited on the hidden workspace')
		return;
	} else {
		let desktopToMoveTo = {
			[defaultDesktop]: workDesktop,
			[workDesktop]: defaultDesktop
		}

		let destination = desktopToMoveTo[activeDesktop]
		let moveWindow = `wmctrl -i -r '${activeWindowId}' -t ${destination}`;
		utils.functions.runCommand(moveWindow)
		//after moving the window to other desktop, set it as last item
		// resolveWindowPosition(activeWindowId, destination)
	}
}

function listNumberOfHiddenWindows(options = []) {
	let layout = getLayout();
	let hiddenWindowArray = layout[hiddenDesktop]

	let objectKeys = Object.keys(hiddenWindowArray)
	let size = objectKeys.length
	sendNotification(`hidden: ${size} windows`, 500)
}

function showMap(options = []) {
	console.log({ functionMapping })
}

/**
 * returns the windowId and resident desktopNumber, if it exists
 */
function getWindowDetailsFromName() {

}

function launchApp(options = []) {
	const desktopLayout = getLayout();
}

function toggleSocialGptWindows() {

}

async function localizeWindows() {
	const layout = getLayout(true)
	const defaultCommand = 'echo start'

	const windowTitlePatternDesktopMap = {
		'chatgpt': workDesktop,
		"whatsapp": defaultDesktop,
		'mtn': hiddenDesktop,
		'⬜️': defaultDesktop
	}

	const windowClassPatternDesktopMap = {
		'insomnium': workDesktop,
		'bitwarden': hiddenDesktop,
		'trilium notes': hiddenDesktop
	}
	let commandToRun = `${defaultCommand}`;

	for (const index in layout) {
		const iterationWindowId = layout[index]['windowId'];
		const iterationWindowTitle = layout[index]['windowName'];
		const iterationWindowClass = layout[index]['windowClass'];

		for (const titleIndex in windowTitlePatternDesktopMap) {
			const match = iterationWindowTitle.match(RegExp(`${titleIndex}`, 'gi'))
			if (match) {
				// console.log({ titleIndex, match, iterationWindowTitle })
				commandToRun = `${commandToRun} && ${commandFullPaths.wmctrl} -i -r '${iterationWindowId}' -t ${windowTitlePatternDesktopMap[titleIndex]}`;
			}
		}

		for (const classIndex in windowClassPatternDesktopMap) {
			const match = iterationWindowClass.match(RegExp(`${classIndex}`, 'gi'))
			if (match) {
				console.log({ classIndex, match, iterationWindowClass })
				commandToRun = `${commandToRun} && ${commandFullPaths.wmctrl} -i -r '${iterationWindowId}' -t ${windowClassPatternDesktopMap[classIndex]}`;
			}
		}
	}

	//added all the window movement commands

	if (commandToRun === defaultCommand) {
		console.log('nothing to do')
	} else {
	//run command

	}

	console.log({ commandToRun })
}

async function test() {
	console.log('hello')
}

async function startOperationalLoop(options = []) {
	if (isMainThread) {
		panelColorWorker = new Worker(ensureCorrectDesktopPanelColor, { workerData: 'data' })
	} else {
		console.log('nothing to do')
	}
}

function renameActiveWindow(options = []) {
	console.log('starting')
	const activeWindowId = getActiveWindowId();
	// execFileSync(`notify-send "hello id: ${activeWindowId}"`, { shell: '/bin/sh'})

	// --entry-text "initial window name"
	const result = utils.functions.runCommand(`zenity --entry --title "New Window Title" --text "Enter name:" 2>/dev/null | cat`)

	//if no string is provided, exit gracefully
	if (result.length === 0) { return }

	const commandToRenameWindow = `xprop -id ${activeWindowId} -f _NET_WM_NAME 8u -set _NET_WM_NAME '${result}'`
	// console.log(result)
	utils.functions.runCommand(commandToRenameWindow, true)

	// execFileSync(`notify-send ${result}`, { shell: '/bin/sh'})
	// execFileSync('notify-send hello', { shell: '/bin/sh'})
}

function init() {
	const arg = process.argv
	const argument = arg.slice(2)[0]
	const options = arg.slice(3, (arg.length - 1))

	//if argument is truthy
	if (Boolean(argument)) {
		let functionToRun = functionMapping[argument]
		try {
			if (functionToRun) {
				functionToRun(options)
			} else {
				printMapping();
			}
		} catch (error) {
			logError(error)
			sendNotification('there was an error')
		}
	} else {
		printMapping()
	}
}


module.exports.utils = utils
module.exports.defaultDesktop = defaultDesktop
module.exports.workDesktop = workDesktop
module.exports.hiddenDesktop = hiddenDesktop


init();

/**
 * three finger swipe up hide window
 * meta+shift+space unhide all windows
 * three finger left, hide active window
 * four fingers left and right, switch workspace
 */

//command to maximize windows
// wmctrl -i -r <window_id> -b add,maximized_vert,maximized_horz

// work green color
// 'work': 'xfconf-query -c xfce4-panel -p /panels/panel-1/background-rgba -t double -s 0.011667 -t double -s 0.166667 -t double -s 0.022175 -t double -s 1.000000',
